Modo interativo
    Maneira de testar suas variáveis e scripts antes mesmo
    de rodar o código 
    Existem duas maneiras de fazer isso: 
        1. Ambiente interativo genérico: 'python' no terminal
        2. Ambiente interativo para programa: 'python nome.python'
        no termina. 
    Além disso temos os comandos: dir() e help(), que aceitam
    parâmetros e nos informam as bibliotecas usadas por um objeto,
    e como utilizá-las, respectivamente. 

Variáveis   
    Declarações: 
        1. age = 23 
           name = ' Guilherme'
        2. age, name = (23, 'Guilherme')
    Tipos: 
        Python NÃO TEM constantes - normalmente usamos letras maiúsculas
        para convencionar isso. 
    Inteiros: 
        Dividir com // mantém o estado de inteiro de um número. 

Print: 
    Podemos adicionar como será formatado o final. 
        print(...,..., end='\n') -- pula linha após exibir todas as variáveis
    Podemos adicionar como as variáveis serão separadas.
        print(...,...,sep='#')

Operadores Lógicos:
    Usamos as seguintes palavras: 
        Or, and, not, is, is not, in, not in. 
    Usamos os seguintes símbolos:
        >, <, =, (). 
If: 
   1.   if condição: 
        elif condição:
        else:
   
   2.   retorno_verdadeiro if condição else retorno_falso
        "Maior" if num>5 else "Menor"

For: 
    É usado para percorrer um objeto iterável ou para repetir 
    uma estrutura passível de repetição. 
        1. for letra in texto: 
                if letra == 'a'
                    ...
            Aqui estamos percorrendo a string texto, sendo 
            letra os valores atuais. 
    Usamos range para obter uma sequência com início e fim. 
        2. range(start, stop[,step]) -> range(i,j) --> i, ..., j-1
           list(range(stop)) -> list(range(10)) --> 0,...,9
           range(stop) --> range(9) --> 0, 9

           **List o formata como uma listagem de 0 a 9,
           formato não usado em for.
    continue: Quando encontrado dentro de um loop, o continue faz 
    com que o programa pule o restante da iteração atual e avance
    para a próxima iteração do loop. Se estivermos dentro de um loop
    for, o programa irá para o próximo valor na sequência de iteração.
    Se estivermos dentro de um loop while, o programa avalia novamente
    a condição do while e, se verdadeira, inicia a próxima iteração

            i = 0
            n = 0
            while i < 5:
            i = 1 + i
            if i == 3:
                continue
            n += i
            print(i)
    **Ele não imprime nada em i == 3, pois pula pro próximo passo da iteração 
    como existe apenas uma estrutura. s

While: 
    Pode ser usado de duas maneiras: 
    1.  while opcao != 3: 
            if opcao == 1: 
                print("Sacando...")
                break
            else:
                print("Depositando...")
                break

    2.  while opcao != 3: 
            if opcao == 1: 
                print("Sacando...")
                break
            else:
                print("Depositando...")
                break
        else: 
            print("Saindo...")

Strings: 
    Para acessar cada caractere de uma string, precisamos apenas acessá-lo como um vetor: 

        palavra[0]

    Métodos: 

        Letras 
            1. .upper() - todas maiúsculas. 
            2. .lower() - todas minúsculas. 
            3. .title() - primeira letra da string fica maiúscula. 

        Espaços brancos 
            1. .strip() - espaços da esquerda e direita.
            2. .lstrip() - apenas espaço da esquerda. 
            3. .rstrip() - apenas espaço da direita. 

        Junções e centralizações
            1. .center(numero a ocupar, caractere que estara ao redor da palavra )
                curso.center(10, "+") --> ++Python++
            2. (caractere que será a junção).join(palavra a ser juntada)
                '.'.join(curso) --> P.y.t.h.o.n
                curso.join('.') --> . 
                curso.join('...') --> . .Python.Python.
    
   Interpolação de variáveis: substituição de variáveis no método print. 
    1. Usando %
        - Compatível, porém muito complexa. 

        print("João tem %d anos" %(nome))

    2. Utilizando método 'format':
        print("Eu gosto de {} e {}!".format(banana, maca))

        print("Eu gosto de {1} e {0}!".format(maca, banana))

        print("Eu gosto de {fruta1} e {fruta2}!".format(fruta1='maca', fruta2='banana'))

        **Podemos definir um dicionário e fazer o que foi feito no passo acima, porem usando 
        .format(**frutas) --> sendo frutas o nome do dicionário

    3. Utilizando 'f strings'

        print(f"Eu gosto de {maca} e {banana}!")

    Formatação com fstring: 

        print(f"Valor de PI: {PI:.2f}") -- duas casas dps da vírgula 

        print(f"Valor de PI: {PI:10.2f}") -- duas casas dps da vírgula e 10 casas úteis antes 

    Fatiamento de strings: retorna substrings
        - [start:stop:step]
        --> start é a casa inicial 
        --> stop é a casa final 
        --> step é o obstáculo -> step = 2 --> pula de duas em duas casas


        b = "Hello, World!"
        print(b[2:5]) --> "llo,"
        print(b[:5]) --> "Hello,"
        print(b[2:]) --> "lo, World!"
        print(b[:]) --> "Hello, World!"
        print(b[::-1]) -->  # Saída: lagel é nohtyP (string invertida)


    Strings de múltiplas linhas
        Definidas informando 3 aspas simples ou dulas durante a atribuição:
            """DASDAS
            DASDASDA
            DASDASDDA"""
        **Espaços em branco são considerados

Listas: Armazenam, de maneira sequencial, qualquer tipo de objeto ou dado. 
    Criação de listas -- 
        1. Usando o construtor 'list'(iterável)
            nomes = list("python") --> ['p', 'y', 't', 'h', 'o', 'n']

        2. Usando a função 'range'
            numeros = list(range(10)) --> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        3. Colocando valores separados por vírgulas dentro de colchetes. 
            frutas = ["uva","banana","pera"]  --> ['uva', 'banana', 'pera']

    Acessando listas - São sequencias, podemos acessar seus dados pelos índices. 
        Indices positivos: começa em 0
            frutas[0] = 'uva'
        Indices negativos: começa em -1 
            frutas[-3] = 'uva'
    
    Listas aninhadas - Listas que armazenam outras listas. 
        Matriz = [
            [1,2,3]
            [4,5,6]
            [6,7,8]
        ]

        Matriz[0][0] = 1

    Fatiamento de listas - pega valores específicos do intervalo determinado. (mesmo funcionamento das strings)

    Iteração em lista - Apenas utilizando for
        frutas = ["uva","banana","pera"]
        for fruta in frutas -- fruta admite valores de indice crescente a cada passo da iteração
    
    Enumeração - Usado para saber o índice do objeto desejado. Retorna dois valores, o da lista e um número (índice). 
        frutas = ["uva","banana","pera"]
        for indice, fruta in enumerate(frutas): 
            print(f"{indice}: {fruta}")
**precisamos ter essas duas variáveis no for, caso contrário será inútil 

    Compreensão de listas - sintaxe curta para criar nova lista baseada em uma já existente. 
    Aplicando filtro ou modificando os valores já existentes. 
        1. Filtro: complicado X facilitado
            a.  numeros = [1,2,3,4]
                pares = []

                for numero in numeros: 
                    if numero % 2 == 0: 
                        pares.append(numero)

            b.  numeros = [1,2,3,4]
                pares = [numero for numero in numeros if numero % 2 == 0]
        
        2. Modificando: complicado X facilitado
            a.  numeros = [1,2,3,4]
                quadrado = []

                for numero in numeros: 
                    quadrado.append(numero**2)

            b.  numeros = [1,2,3,4]
                quadrado = [numero**2 for numero in numeros]

    Métodos da lista: 
        1. Append: nome_lista.append(objeto) (sem retornos)
        2. Clear: nome_lista.clear() (sem retornos)
        3. Copy: nova_instancia = nome_lista.copy() (tem retornos)
        4. Count: nome_lista.count(objeto_a_ser_contado) (sem retornos)
        5. Extend: nome_lista.extend(nome_lista_a_ser_adicionada) -- Não guarda nova lista, apenas extende (sem retornos)
        6. Index: nome_lista.index(objeto_a_ser_achado) -- Retorna indice da primeira ocorrencia (sem retornos)
        7. Pop: nome_lista.pop() -- Como uma pilha, retira o último elemento adicionado (sem retornos)
        8. Reverse: nome_lista.reverse() -- Inverte lista (sem retornos)
        9. Sort: nome_lista.sort(key = {lambda x: len(x) -- função anônima, retorna o número de letras}, reverse = {true ou false} ) -- Arruma lista (sem retornos) 
        10. Sorted: sorted(nome_lista, key = {lambda x: len(x) -- função anônima, retorna o número de letras}, reverse = {true ou false} ) (tem retornos)
   
    IsInstance: Verificação de que uma estrutura é uma lista
        carros = ["gol"] 
        print(isinstance(carros, list)) --> True

Tuplas: São as 'irmãs' da lista. Porém, são imutáveis. **Podem armazenar objetos mutáveis, como as listas. 
    Criação de tuplas: 
        1. Com 'tuple' 
            tuple('python')

        2. Com valores separados por vírgulas em parentêses. 
            frutas = ('uva','abacaxi',) --> **Devemos ter última vírgula, caso contrário teremos problemas para o interpretador. 
    
    Acessando tuplas: 
        frutas[0] = frutas[-2] = 'uva'
    
    Tuplas aninhadas: Não irei repetir, o funcionamento é igual.
    Fatiamento: Também pode ser aplicado a tuplas, uma vez que só impacta nossa visualização dela.
    IsInstance: Verificação de que uma estrutura é uma tupla
        carros1 = ("Gol")
        carros = ("gol",) 
        print(isinstance(carros1, tuple)) --> False --> Precisa da vírgula 
        print(isinstance(carros, tuple)) --> True

Conjuntos: Coleção de objetos que não possui objetos repetidos. Usamos o método set para defini-los ou para eliminar itens 
        duplicados de um iterável. **Não tem ordem, ou seja, podemos ter diferentes ordem em diferentes sistemas!!

********Os conjuntos em Python não suportam indexação e nem fatiamento, caso queira acessar os seus valores é necessário converter o conjunto para lista.
            meu_conjunto = {1, 2, 3, 4, 5}

            # Tentativa de indexação (gera erro):
            # print(meu_conjunto[0]) # TypeError: 'set' object is not subscriptable

            # Convertendo para lista:
            meu_conjunto_lista = list(meu_conjunto)
            print(meu_conjunto_lista[0])  # Saída: 1

            # Convertendo para tupla:
            meu_conjunto_tupla = tuple(meu_conjunto)
            print(meu_conjunto_tupla[0]) # Saída: 1

        Criando conjuntos: 
            1. set() - Elimina duplicatas
                numeros = set([1,2,3,1,4]) --> {1,2,3,4} **Eliminou duplicações
                abacaxi = set("abacaxi") --> {"b","a","c","i","x"}
            2. Chaves - Não elimina duplicatas
                numeros = {1,2,3,4,5,6,3,1,2}
                abacaxi = {"abacaxi"}

        Função enumerate: Mesma maneira da lista

        Métodos de Set(): 
            1. Union - conjunto_a.union(conjunto_b)
            2. Intersection - conjunto_a.intersection(conjunto_b)
            3. Difference - conjunto_a.difference(conjunto_b) --> Elementos que está apenas no invocador
            4. Symetric Difference - conjunto_a.symetric_difference(conjunto_b) --> Todos os elementos que não estão na intersecção 
            5. IsSubset - conjunto_a.issubset(conjunto_b) --> Os elementos de A estão em B?
            6. IsSuperset - conjunto_a.issuperset(conjunto_b) --> Os elementos de B estão em A?
            7. IsDisjoint - conjunto_a.isdisjoint(conjunto_b) --> Todos os elementos de B não estão em A?
            8. Add - conjunto_a.add(elemento) --> Adiciona elementos não existentes. 
            9. Clear
            10. Copy
            11. Discard - conjunto_a.discard(elemento) --> Descarta certo elemento, não da  erros com não existentes. 
            12. Pop - Tira os primeiros valores, oq é incomum!!!!!!!!!!!!
            13. Remove - conjunto_a.remove(elemento) --> Mesmo que discar, porém dá erros quando elemento não existe. 
            14. Len - conjunto_a.len() --> Tamanho da estrutura



Dicionários: Conjunto não ordenado de pares chave. Onde cada chave deve ter um valor.
    Criação de um dictionaire: 
        Delimitados por {}, devem conter uma lista do tipo 'chave:valor' separada por vírgulas. 
        
        ex. 
            1. dicionario = {"giovanna":"noventa", "sandy":"junior"} 
            2. dicinario = dict(nome="Giovanna", idade=28)
            3. dicionario["nota"] = "10" *Adiciona esse atributo ao dicionário

    Acesso de dados: 
        Podemos acessar e modificar o valor por: 
            Acessando -- dicionario["giovanna"] --> noventa
            Acessando e Modificando -- dicionario["giovanna"] = nascimento 
    
    Dicionários aninhados: possível e usado. 
        people = {1: {'name': 'John', 'age': '27', 'sex': 'Male'},
                  2: {'name': 'Marie', 'age': '22', 'sex': 'Female'}}

        Acessando -- people["1"]["name"]

    Iterar dicionários: 
        Podemos percorrer o dicionário com for.

        1. Acessando dicionários aninhados: 
            a. for chave in people: *Retorna apenas a chave e os valores dessa cheve, nesse caso, todo o outro dicionário. 
                print(chave, people[chave])

            b. for chave, valor in people.items():
                print(chave, valor) 

    Métodos do dict: 
        1. Clear: nome_dicionario.clear()
        2. Copy: nome_novo = nome_dicionario.copy() (retorna dicionario à cópia)
        3. FromKeys: nome_dicionario.fromkeys([chaves desejadas], valor de redefinição) **Redefine o valor de certas chaves 
        4. Get: nome_dicionario.get(chave, valores) **
        5. Items: nome_dicionario.items() **Pega todos os valores e chaves 
        6. Keys: nome_dicionario.keys() 
        7. Pop: nome_dicionario.pop(chave ou valor a ser retirado)
        8. PopItem: nome_dicionario.popitem(tira chave)
        9. SetDefault: nome_dicionario.setdefault(chave:valor) -- Define uma chave com um valor padrão 
        10. Update: nome_dicionario.update() -- Atualiza valor de chave
        11. Values: nome_dicionario.values()
        12. In: Podemos testar se chaves existem 
        13. Del: del nome_dicionario[chave][chave]


Funções: 
    Parâmetros especiais: 
        Por padrão, podemos usar a posição ou o nome para passar um valor para uma função. De modo que, 
        f(199,Loiro) ou f(cor=Loiro, valor=199). Porém, podemos expandir isso para: posição, nome e po
        sição e nome. 

        1. Positional Only: Antes da barra só aceita por posição, ou seja, sem nome. 
            def criar_carro(modelo, ano, placa, /, marca, motor, combustivel): 
                print(modelo, ano, placa, marca, motor, combustivel)

                criar_carro("Palio", 1999, "ABC-1234", "Fiat", "1.0", combustivel="Gasolina") #Válida
                criar_carro(modelo="Palio", ano=1999, placa="ABC-1234", marca="Fiat", motor="1.0", combustivel="Gasolina") #Inválida
        
        2. Keyword Only: Sempre precisa de nomes. 
            def criar_carro(*,modelo, ano, placa, marca, motor, combustivel): 
                print(modelo, ano, placa, marca, motor, combustivel)

                criar_carro(modelo="Palio", ano=1999, placa="ABC-1234", marca="Fiat", motor="1.0", combustivel="Gasolina") #Válida
                criar_carro("Palio", 1999, "ABC-1234", marca="Fiat", motor="1.0", combustivel="Gasolina") #Inválida

        3. Keyword and positional only: Tudo depois da barra só aceita termos com nome. 
            def criar_carro(modelo, ano, placa, /, *,marca, motor, combustivel): 
                print(modelo, ano, placa, marca, motor, combustivel)

                criar_carro("Palio", 1999, "ABC-1234", marca="Fiat", motor="1.0", combustivel="Gasolina") #Inválida
                criar_carro(modelo="Palio", ano=1999, placa="ABC-1234", marca="Fiat", motor="1.0", combustivel="Gasolina") #Inválida

        ==> def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2)
    
    Parâmetros especiais em funções: 
        1. Uso de Argumentos em Funções:
            Em Python, você pode definir funções que aceitam argumentos posicionais e de palavra-chave.
            No exemplo dado, `def funcao(*args, **kw):`, a função `funcao` aceita argumentos posicionais (`*args`) e argumentos de palavra-chave (`**kw`).
            Ao executar `funcao("python", 2022, curso="dio")`, `args` conterá `("python", 2022)` e `kw` conterá `{"curso": "dio"}`.    
         => *args e **kwargs controlam quantos argumentos podem ser passados. 
                *args → junta argumentos posicionais "extras" em uma tupla
                **kwargs → junta argumentos nomeados "extras" em um dicionário


    Alterações de variáveis globais em funções: 
        - Para alterar uma variável global dentro de uma função, precisamos redeclarara como global. Para apenas acessá-la, não precisamos fazer isso. 
        Ex. 
            saque 

            def sacar(): 
                global saque 


Programação Orientada A Objetos (POO): É um estilo de programação. ABstrai problemas em objetos reais do mundo
    facilitando o entendimento do código e tornando-o mais modular e extensível. 

    Conceitos: 
        - Classe: Define características (campos) e comportamentos (métodos) de um objeto pertencente a ela. 
            class Cachorro: 
                def __init__(self** Define objeto sem precisar de parâmetros, nome, cor, acordado=True): **Construtor
                    self.nome = nome 
                    self.cor = cor 
                    self acordado = acordado
                def latir(self):    
                    print("AuAu")

        - Objeto: São instancias de uma classe que terão suas características e comportamentos definidos por ela.  
            cao = Cachorro("chappie", "amarelo", False) **Criação de instância
            cao.latir() --> AuAu

        - Construtores: É um método executado quando uma nova instância da classe é criada. Inicializamos o estado do nosso objeto. 
        Para declarar método utilizados a palavra '__init__': 
            def __init__ (self, "parâmetros"): 

        - Destrutores: É um método executado quando uma instância é destruída. O Python tem um coletor de lixo, o que otimiza o 
        gerenciamento de memória. Para declarar esse método utilizamos a paralavra '__del__':
            def __del__(self): 
                pode ter alterações 
            del cao -> Realiza operação de deleção da instância
        
        - Herança: 
            - Herança em POO: Capacidade da classe filha em derivar ou herdar as características e comportamentos da classe mãe. 
                Iremos extender uma classe mãe para sua filha. 

                class A: 
                    pass //Só para nn declarar nenhum argumento e não dar erro 
                
                class B(A):--> Aqui temos a extensão como B extends A 
                    pass
            
            - Herança Simples: Quando uma classe filha herda apenas de UMA classe mãe. 
            - Herança Múltipla: Quando uma classe filha herda de várias classes mãe. 

                class C(A,B): 
                    pass 
        
        - Encapsulamento: 
            - O que é? Descreve a ideia de agrupar dados e métodos que manipulam dados em um uma unidade. Desse modo, 
            , por meio do mesmo, temos a habilidade de impor restrições ao acesso direto a variáveis e métodos, evitando
            possíveis modificações acidentais. Nesse caso, apenas o método do objeto altera valor de variável. 
            - Tipos: **Java possui 4 tipos 
                - Público: Qualquer classe pode acessá-lo. 
                - Privavdo: Pode ser apenas acessado por sua classe. 
            ** Todos os recursos são públicos, menos quando seu nome se inicia com _. (Convenção)

                class Conta: 
                    def __init__(self, saldo=0):
                        self._saldo = saldo 
                    def depositar(self, valor):
                        pass 

            - Property()/@property:
                - Te possibilita a criação de atributos gerenciados em sua classe. Com getters e setters para apenas a sua classe. 

                    class Circle:
                        def __init__(self, radius):
                            self._radius = radius  # Convention for "protected" attribute

                        @property
                        def radius(self):
                            """The radius property."""
                            return self._radius

                        @radius.setter
                        def radius(self, value):
                            if value < 0:
                                raise ValueError("Radius cannot be negative")
                            self._radius = value

                        @radius.deleter
                        def radius(self):
                            del self._radius

                        # Usage
                        c = Circle(5)
                        print(c.radius)  # Calls the getter
                        c.radius = 10    # Calls the setter
                        print(c.radius)
                        # del c.radius   # Calls the deleter
            
        
        - Polimorfismo: Significa mesmo nome de função, mas assinaturas diferentes. Sendo utilizado para tipos diferentes. 
            Ou seja, dependendo do tipo da instância, teremos resultados diferentes, se adaptando a origem dele. ((Ex: Função len()))
            **Só ocorre com herança
            - Com herança: Quando ocorre uma herança, que envolve classe mãe-filha. Podemos modificar um método da classe mãe na classe filha, 
            de modo, adaptá-lo da melhor forma àquele objeto. Precisamos apenas definir o mesmo método com as mesmas assinaturas. 
                    class Animal:
                        def speak(self):
                            return "This is a generic animal sound."

                    class Dog(Animal):
                        def speak(self):
                            return "Woof!"

                    class Cat(Animal):
                        def speak(self):
                            return "Meow!"

                    # Demonstrating polymorphism
                    animals = [Animal(), Dog(), Cat()]

                    for animal in animals:
                        print(animal.speak())

        - Variáveis de Instância X De Classe: 
            - Atributos de classe são compartilhados entre objetos, enquanto atributos de instância são distintos para 
            cada objeto (cada objeto tem um cópia delas). Resumindo, variáveis de instância são as definidas no construtor. 

            class Carro:
                numero_de_rodas = 4  # Variável de classe

                def __init__(self, marca, modelo):
                    self.marca = marca  # Variável de instância
                    self.modelo = modelo  # Variável de instância

                def detalhes(self):
                    print(f"Marca: {self.marca}, Modelo: {self.modelo}, Rodas: {Carro.numero_de_rodas}")

            # Criando instâncias
            carro1 = Carro("Toyota", "Corolla")
            carro2 = Carro("Honda", "Civic")

            # Acessando variáveis
            print(f"Rodas do carro1: {carro1.numero_de_rodas}")  # Acessando por instância
            print(f"Rodas do carro2: {carro2.numero_de_rodas}")  # Acessando por instância
            print(f"Rodas da classe: {Carro.numero_de_rodas}")  # Acessando por classe

            carro1.detalhes()

        
        - Tipos de método: 
            - Classe(@classmethod): Estão ligado à classe e não ao objeto. Têm acesso ao estado da classe, pois recebem parâmetro que aponta
            para classe e não para uma instância do objeto. 
            - Estático(@staticmethod): Também vinculado á classe, ele dispensa o argumento self ou cls. Não modifica ou acessa o estado da classe. 
                --> Método Estático = Funções utilitárias
                class Pessoa:
                    populacao = 0  # atributo da classe

                    def __init__(self, nome):
                        self.nome = nome
                        Pessoa.populacao += 1

                    @classmethod
                    def total_pessoas(cls):
                        # cls faz referência à própria classe Pessoa
                        return f'Total de pessoas: {cls.populacao}'

                    @staticmethod
                    def saudacao():
                        # não acessa nem o estado da instância (self) nem da classe (cls)
                        return 'Olá! Seja bem-vindo(a)!'

                # Criando instâncias
                p1 = Pessoa("Ana")
                p2 = Pessoa("João")

                # Chamando método de classe
                print(Pessoa.total_pessoas())  # Total de pessoas: 2

                # Chamando método estático
                print(Pessoa.saudacao())       # Olá! Seja bem-vindo(a)!

        - Classes Abstratas: Também chamadas de ABC (Abstract Base Classes), serve the modelo para outras classes. Não podendo ser instanciada, apenas
            utilizada como modelo. Al´´em disso, contém métodos abstratos que deverão ser declarados por outras classes que forem a utilizar. 
            Utilizaremos a palavra 'pass'como placeholder e @abstractmethod como o definidor do método abstrato. 

            from abc import ABC, abstractmethod 

            class Vehicle(ABC): **ABC define classe como abstrata 
                @abstractmethod
                def start_engine(self):
                    pass

                @abstractmethod
                def stop_engine(self):
                    pass

            class Car(Vehicle):
                def start_engine(self):
                    print("Car engine started.")

                def stop_engine(self):
                    print("Car engine stopped.")

            # Attempting to instantiate Vehicle will raise a TypeError
            # vehicle = Vehicle()

            my_car = Car()
            my_car.start_engine()
            my_car.stop_engine()
        
        - Interfaces: define padrões a serem, obrigatoriamente, definidos por todas as classes que a usarem como base. 
        Aqui dizemos que existe um "contrato de métodos". Não existe nativamente, iremos ver exemplo com ducktyping e protocols.
        Utilizamos classes abstratas para fazer os contratos. 
        
            com Protocol: não força em tempo de execução, ferramentas como mypy conseguem verificar isso (Adicionar!!)

            from typing import Protocol

            class Forma(Protocol):
                def area(self) -> float: ...
                def perimetro(self) -> float: ...


            class Retangulo:
                def __init__(self, largura, altura):
                    self.largura = largura
                    self.altura = altura

                def area(self) -> float:
                    return self.largura * self.altura

                def perimetro(self) -> float:
                    return 2 * (self.largura + self.altura)


            def mostrar_dados(f: Forma):
                print("Área:", f.area())
                print("Perímetro:", f.perimetro())


            r = Retangulo(3, 4)
            mostrar_dados(r)  # funciona, mesmo sem herdar de Forma

            com duck typing puro: 
                class Quadrado:
                    def __init__(self, lado):
                        self.lado = lado

                    def area(self):
                        return self.lado ** 2

                def mostrar_area(figura):
                    print("Área:", figura.area())

                mostrar_area(Quadrado(5))  # Aceito se tiver método area()

Decoradores: 
    - Inner functions: é possível definir funções dentro de outras funções, as chamadas funções
    internas. 
        def pai():
            print("djasd")
            def filho1(): 
                print("dkasjdk")
            filho1()
    
    - Retornando funções: Em pyhton, é possível que funções sejam retornadas por outras funções. 
        def calcula(operacao)
            def somar(a,b):
                return a + B
            def subtrair(a,b):
                return a - B
            if operacao == "+"
                return somar
            else: 
                return subtrair
        resultado = calcular("+")(1,3) ==> somar(1,3)
        print(resultado) ==> 4
    
    - Decorador simples: 
        def meu_decorador(funcao):
            def envelope():
                print()
                funcao()
                print()
            return envelope
        def ola_mundo():
            print("Ola mundo")

        ola_mundo = meu_decorador(ola_mundo) --> Passamos uma função por parâmetro
        ola_mundo()

        OUUU podemos usar apenas o símbolo '@nome_da_funcao_que_aceita_funcao_como_parametro' para simplificar

        def meu_decorador(funcao):
            def envelope():
                print()
                funcao()
                print()
            return envelope
        @meu_decorador
        def ola_mundo():
            print("Ola mundo")

        ola_mundo()
    
    - Funções de decoração com argumentos: Podemos usar *args e **kwargs na função interna, com isso 
    ela aceitará um número arbitrário de argumentos posicionais e de palavras-chave. 

    def duplicar(func):
        def envelope(*args, **kwargs):
            func(*args,**kwargs)
            func(*args,**kwargs)
        return envelope
    
    @duplicar
        
    - Retornando valores de funções decoradas: podemos decidir entre retornar o valor da função decorada
    ou não. Para que o valor seja retornando a função de envelope deve retornar o valor da função decorada. 
        
        def duplicar(func): 
            def envelope(*args, **kwargs): 
                func(*args, **kwargs)
                return func(*args, **kwargs)
            return envelope 

        @duplicar
        def aprender(tecnologia): 
            print(f"Estou aprendendo {tecnologia}")
            return tecnologia.upper()
        
        tecnologia = aprender("Python")
        print(tecnologia)
        

    - Instrospecção: É a capacidade de um objeto saber sobre seus próprios atributos em tempo de execução. 

        import functools 

        def duplicar(func):
            @functools.wraps(func)
            def envelope(*args, **kwargs):
                func(*args, **kwargs)
                return func(*args, **kwargs)
            return envelope 
        
        @duplicar
        def aprender(tecnologia):
            print(f"Estou aprendendo {tecnologia}")
            return tecnologia.upper()
        
        tecnologia = aprender("Python")
        print(tecnologia)

Iteradores e Geradores: 
    Iterador: Objeto que contém um número contável de valores que podem ser iterados, de modo a percorrer todos
    os valores. Podemos fazer isso através de "__iter__()" e "__next__()". 
    - Funções: ler arquivos grandes e iterar linha a linha do arquivo. 
    - Exemplo: 

            class FileIterator: 
                def __init__(self,filename):
                    self.file = open(filename)
                
                def __iter__(self): 
                    return self
                
                def __next__(self):
                    line = self.file.readLine()
                    if line != '':
                        return line 
                    else:
                        self.file.close()
                        raise StopIteration 
                    
            #Uso 
                for line in FileIterator('large_file.txt)
                    print(line)
    
    Gerador: São tipos especiais de iteradores, ao contrário das listas ou outro iteráveis, não armazenam todos os seus 
    valores na memória. São definidos usando funções regulares, mas, ao invés de retornam valores usando 'return', utilizam 
    'yield'. 
        - Uma vez que um item gerado é consumido, ele não pode ser acessado novamente. 
        - Estado interno de um gerador é mantido entre chamadas. 
        - A execução de um gerador é pausada na declaração 'yield' e retomada daí na próxima vez que ele for chamado. 
        - Funções geradoras são declaradas normalmente, mas usam 'yield' para produzir valores um a um.
        - Para obter valores de um gerador, usamos next() ou um loop for.
        - Geradores são úteis para trabalhar com grandes volumes de dados ou fluxos infinitos.
        - Exemplo prático:
            def contador(max):
                n = 0
                while n < max:
                    yield n
                    n += 1
            # Uso:
            for numero in contador(5):
                print(numero)  # Saída: 0 1 2 3 4

        - Também é possível criar geradores com expressões geradoras:
            quadrados = (x*x for x in range(5))
            for q in quadrados:
                print(q)  # Saída: 0 1 4 9 16

        - Vantagens dos geradores:
            * Economizam memória, pois produzem valores sob demanda.
            * Permitem criar pipelines de processamento de dados.
            * Podem ser infinitos (ex: gerador de números primos, Fibonacci, etc).

        - Diferença entre função normal e geradora:
            * Função normal retorna um valor e encerra.
            * Função geradora pode pausar e continuar, retornando vários valores ao longo do tempo.


##Pacotes
1. Data, hora e fuso horário: 
    O módulo datetime é o principal para manipulação de datas e horas em Python.
    Permite criar, comparar, formatar e converter datas e horários, além de trabalhar com fusos horários.

    Principais classes:
        - datetime.date: representa apenas a data (ano, mês, dia)
        - datetime.time: representa apenas o horário (hora, minuto, segundo, microssegundo)
        - datetime.datetime: representa data e hora juntos
        - datetime.timedelta: representa a diferença entre datas/horas
        - datetime.timezone: representa informações de fuso horário

    Exemplos de uso:
        import datetime

        # Data atual
        hoje = datetime.date.today()
        print(hoje)  # Ex: 2025-08-23

        # Data e hora atual
        agora = datetime.datetime.now()
        print(agora)  # Ex: 2025-08-23 14:30:00.123456

        # Criando datas e horas específicas
        data = datetime.date(2023, 12, 25)
        horario = datetime.time(14, 30, 0)
        dt = datetime.datetime(2023, 12, 25, 14, 30, 0)

        # Formatando datas e horas (str -> data/hora e vice-versa)
        data_str = '2025-08-23 15:00:00'
        dt_obj = datetime.datetime.strptime(data_str, '%Y-%m-%d %H:%M:%S')
        print(dt_obj)
        print(dt_obj.strftime('%d/%m/%Y %H:%M'))  # 23/08/2025 15:00

        # Diferença entre datas
        d1 = datetime.date(2025, 8, 23)
        d2 = datetime.date(2025, 8, 20)
        delta = d1 - d2
        print(delta.days)  # 3

        # Adicionando/subtraindo datas
        nova_data = d1 + datetime.timedelta(days=10)
        print(nova_data)  # 2025-09-02

        # Trabalhando com fuso horário
        from datetime import timezone, timedelta
        fuso_brasilia = timezone(timedelta(hours=-3))
        agora_brasilia = datetime.datetime.now(fuso_brasilia)
        print(agora_brasilia)

    Observações:
        - O módulo datetime é robusto e cobre a maioria das necessidades de manipulação de datas/horas.
        - Para fusos horários mais avançados, pode-se usar a biblioteca externa pytz.
    
2. Manipulando arquivos em Python
    Em Python, a manipulação de arquivos é feita principalmente com a função open().
    É possível ler, escrever, criar e modificar arquivos de texto e binários.

    Modos de abertura:
        - 'r': leitura (padrão)
        - 'w': escrita (cria novo arquivo ou sobrescreve)
        - 'a': append (adiciona ao final do arquivo)
        - 'x': cria novo arquivo, erro se já existir
        - 'b': modo binário (ex: 'rb', 'wb')
        - 't': modo texto (padrão)
        - '+': leitura e escrita

    Exemplo básico de leitura:
        with open('arquivo.txt', 'r') as f:
            conteudo = f.read()
            print(conteudo)

    Exemplo de escrita:
        with open('saida.txt', 'w') as f:
            f.write('Olá, mundo!\n')

    Exemplo de leitura linha a linha:
        with open('arquivo.txt', 'r') as f:
            for linha in f:
                print(linha.strip())

    Exemplo de adicionar conteúdo (append):
        with open('log.txt', 'a') as f:
            f.write('Nova linha de log\n')

    Leitura e escrita em arquivos binários:
        with open('imagem.png', 'rb') as f:
            dados = f.read()
        with open('copia.png', 'wb') as f:
            f.write(dados)

    Métodos úteis:
        - read(): lê todo o conteúdo
        - readline(): lê uma linha
        - readlines(): retorna lista de linhas
        - write(): escreve string
        - writelines(): escreve lista de strings

    Boas práticas:
        - Sempre usar with para abrir arquivos (garante fechamento automático)
        - Tratar exceções com try/except para evitar erros em arquivos inexistentes
        - Para arquivos grandes, prefira ler linha a linha

    Exemplo de tratamento de erro:
        try:
            with open('dados.txt', 'r') as f:
                print(f.read())
        except FileNotFoundError:
            print('Arquivo não encontrado!')

    Observação:
        - Para manipulação de arquivos CSV, use o módulo csv.
        - Para arquivos JSON, use o módulo json.
    
3. Gerenciamento de pacotes e boas práticas, seguindo convenções da PEP 8.
    Gerenciamento de pacotes:
        - O Python utiliza o gerenciador de pacotes pip para instalar, atualizar e remover bibliotecas externas.
        - Para instalar um pacote: pip install nome_do_pacote
        - Para listar pacotes instalados: pip list
        - Para atualizar um pacote: pip install --upgrade nome_do_pacote
        - Para remover: pip uninstall nome_do_pacote
        - Para projetos, recomenda-se criar um ambiente virtual (venv):
            python -m venv venv
            # Ativar no Windows: venv\Scripts\activate
            # Ativar no Linux/Mac: source venv/bin/activate
        - Para registrar dependências, use o arquivo requirements.txt:
            pip freeze > requirements.txt
            pip install -r requirements.txt

    Boas práticas e PEP 8:
        - PEP 8 é o guia oficial de estilo para código Python.
        - Principais recomendações:
            * Use 4 espaços por nível de indentação (não use tab).
            * Linhas com no máximo 79 caracteres.
            * Separe funções e classes com duas linhas em branco.
            * Nome de variáveis e funções: snake_case (ex: minha_funcao)
            * Nome de classes: CamelCase (ex: MinhaClasse)
            * Constantes: MAIUSCULAS_SEPARADAS_POR_UNDERSCORE
            * Imports devem ser feitos no início do arquivo, um por linha.
            * Deixe dois espaços antes de comentários em linha.
            * Use docstrings para documentar funções, classes e módulos.
            * Evite espaços desnecessários dentro de parênteses, colchetes ou chaves.
            * Use nomes descritivos para variáveis e funções.
            * Sempre trate exceções de forma específica.
        - Ferramentas úteis:
            * flake8, pylint: analisadores de estilo e erros.
            * black, autopep8: formatadores automáticos de código.
        - Para mais detalhes, consulte: https://peps.python.org/pep-0008/
    
##Introdução Banco de Dados
    Banco de Dados (BD) é uma coleção organizada de dados, geralmente acessados e manipulados por meio de um sistema de gerenciamento de banco de dados (DBMS).

    1. DBMS (Database Management System):
        - Software responsável por criar, gerenciar, manipular e proteger bancos de dados.
        - Exemplos: MySQL, PostgreSQL, SQLite, Oracle, SQL Server.

    2. Tipos de bancos de dados:
        - Relacional: dados organizados em tabelas (linhas e colunas), com relações entre elas. Usa SQL.
            Ex: MySQL, PostgreSQL, SQLite.
        - Não relacional (NoSQL): dados em formatos flexíveis (documentos, chave-valor, grafos, colunas).
            Ex: MongoDB (documentos), Redis (chave-valor), Neo4j (grafos).

    3. SQL (Structured Query Language):
        - Linguagem padrão para manipulação de bancos de dados relacionais.
        - Principais comandos:
            * SELECT: consulta dados
            * INSERT: insere dados
            * UPDATE: atualiza dados
            * DELETE: remove dados
            * CREATE: cria tabelas, bancos, etc.
            * DROP: remove tabelas, bancos, etc.
        - Exemplo:
            CREATE TABLE clientes (
                id INTEGER PRIMARY KEY,
                nome TEXT NOT NULL,
                idade INTEGER,
                email TEXT
            );
            INSERT INTO clientes (nome, idade, email) VALUES ('Ana', 30, 'ana@email.com');
            SELECT * FROM clientes WHERE idade > 25;

    4. Tabelas e tipos de dados:
        - Tabela: estrutura que armazena dados em linhas (registros) e colunas (campos).
        - Tipos de dados comuns:
            * INTEGER: números inteiros
            * REAL/FLOAT: números decimais
            * TEXT/VARCHAR: textos
            * DATE: datas
            * BOOLEAN: verdadeiro/falso

    5. Conceitos importantes:
        - Chave primária (PRIMARY KEY): identifica unicamente cada registro.
        - Chave estrangeira (FOREIGN KEY): cria relação entre tabelas.
        - Índices: aceleram buscas em colunas específicas.
        - Normalização: processo de organizar dados para evitar redundância.

    Observação:
        - Bancos relacionais são ideais para dados estruturados e integridade referencial.
        - Bancos NoSQL são indicados para dados flexíveis, grandes volumes ou alta performance.

##Bancos de Dados
1. Introdução aos bancos relacionais
    - Bancos relacionais organizam dados em tabelas, com linhas (registros) e colunas (campos).
    - SQL (Structured Query Language) é a linguagem padrão para manipulação desses bancos.
    - MER (Modelo Entidade-Relacionamento): diagrama que representa entidades (tabelas), atributos (colunas) e relacionamentos.
    - DER (Diagrama Entidade-Relacionamento): representação gráfica do MER.
    - Configuração do ambiente: pode-se usar MySQL, PostgreSQL, SQLite, etc. SQLite é simples e não requer instalação.
    - Exemplo de criação de tabela:
        CREATE TABLE produtos (
            id INTEGER PRIMARY KEY,
            nome TEXT NOT NULL,
            preco REAL
        );

2. Modelagem de dados relacionais
    - Operações CRUD:
        * CREATE: inserir dados (INSERT)
        * READ: consultar dados (SELECT)
        * UPDATE: atualizar dados (UPDATE)
        * DELETE: remover dados (DELETE)
    - Alterando e excluindo tabelas:
        * ALTER TABLE: altera estrutura (adiciona/renomeia/retira colunas)
        * DROP TABLE: exclui tabela
    - Chaves primárias: identificam unicamente cada registro (PRIMARY KEY)
    - Chaves estrangeiras: criam relações entre tabelas (FOREIGN KEY)
    - Tabelas, colunas e registros: estrutura fundamental dos bancos relacionais
    - Exemplo CRUD:
        INSERT INTO produtos (nome, preco) VALUES ('Camiseta', 49.90);
        SELECT * FROM produtos;
        UPDATE produtos SET preco = 59.90 WHERE id = 1;
        DELETE FROM produtos WHERE id = 1;

3. Normalização de dados
    - Processo de organizar dados para reduzir redundância e dependências.
    - Normalização divide dados em múltiplas tabelas relacionadas.
    - Formas normais (1FN, 2FN, 3FN): regras para garantir integridade e eficiência.
    - Exemplo: separar clientes e endereços em tabelas distintas, ligadas por chave estrangeira.

4. Consultas avançadas
    - Índices: estruturas que aceleram buscas em colunas específicas (CREATE INDEX ...).
    - Funções agregadas: realizam cálculos sobre conjuntos de registros (SUM, AVG, COUNT, MAX, MIN).
        Exemplo: SELECT AVG(preco) FROM produtos;
    - Agrupamento de resultados: GROUP BY permite agrupar registros e aplicar funções agregadas.
        Exemplo: SELECT categoria, COUNT(*) FROM produtos GROUP BY categoria;
    - Junções (JOIN): combinam dados de duas ou mais tabelas relacionadas.
        * INNER JOIN: retorna registros com correspondência em ambas as tabelas
        * LEFT JOIN: retorna todos os registros da tabela da esquerda e correspondentes da direita
        Exemplo:
            SELECT clientes.nome, pedidos.valor
            FROM clientes
            INNER JOIN pedidos ON clientes.id = pedidos.cliente_id;
    - Subconsultas: SELECT dentro de outro SELECT, útil para filtros e cálculos complexos.
        Exemplo: SELECT nome FROM produtos WHERE preco > (SELECT AVG(preco) FROM produtos);

#Introdução ao NoSQL
1. Conhecendo tipos de banco NoSQL
    - NoSQL (Not Only SQL) são bancos de dados não relacionais, ideais para dados flexíveis, grandes volumes ou alta performance.
    - Principais tipos:
        * Documentos: armazenam dados em documentos (JSON/BSON). Ex: MongoDB, CouchDB.
        * Chave-valor: cada item é um par chave-valor. Ex: Redis, DynamoDB.
        * Colunar: dados organizados em colunas/famílias de colunas. Ex: Cassandra, HBase.
        * Grafos: dados como vértices e arestas. Ex: Neo4j, ArangoDB.
    - Vantagens: escalabilidade horizontal, flexibilidade de schema, alta performance para casos específicos.
    - Desvantagens: menos integridade referencial, menos padronização de consultas.

2. Introdução ao MongoDB e instalação
    - MongoDB é o banco de documentos mais popular, armazena dados em documentos BSON (similar ao JSON).
    - Instalação local: baixar de https://www.mongodb.com/try/download/community
    - MongoDB Atlas (cloud): https://www.mongodb.com/cloud/atlas
        * Permite criar clusters gratuitos para testes.
    - Ferramentas úteis: MongoDB Compass (GUI), drivers para Python (pymongo), Node.js, etc.
    - Exemplo de conexão com Python (pymongo):
        from pymongo import MongoClient
        client = MongoClient('mongodb://localhost:27017/')
        db = client['meu_banco']
        colecao = db['clientes']
        colecao.insert_one({'nome': 'Ana', 'idade': 30})
        for doc in colecao.find():
            print(doc)

3. Schema design e boas práticas
    - NoSQL permite schemas flexíveis, mas é importante planejar a estrutura dos documentos.
    - Boas práticas:
        * Definir campos obrigatórios e opcionais.
        * Usar tipos de dados consistentes.
        * Evitar documentos muito grandes (16MB é o limite no MongoDB).
        * Modelar para consultas frequentes (denormalização é comum).
        * Usar referências entre coleções apenas quando necessário.
    - JSON vs BSON:
        * JSON: formato leve, fácil leitura, usado em APIs.
        * BSON: formato binário, suporta mais tipos (datas, binários), usado internamente pelo MongoDB.

4. Conceitos na prática
    - Operações básicas (CRUD):
        * Inserir: colecao.insert_one({'nome': 'João', 'idade': 25})
        * Buscar: colecao.find({'idade': {'$gt': 20}})
        * Atualizar: colecao.update_one({'nome': 'João'}, {'$set': {'idade': 26}})
        * Remover: colecao.delete_one({'nome': 'João'})
    - Índices:
        * Melhoram performance de buscas. Ex: colecao.create_index('nome')
        * Índices compostos: colecao.create_index([('nome', 1), ('idade', -1)])
    - Agregações:
        * Permitem processar e transformar dados em pipelines.
        * Exemplo: contar clientes por idade:
            colecao.aggregate([
                {'$group': {'_id': '$idade', 'total': {'$sum': 1}}}
            ])
    - Performance:
        * Use índices para campos consultados com frequência.
        * Evite consultas que varrem toda a coleção.
        * Monitore o tamanho dos documentos e coleções.
    - Exemplo prático de pipeline de agregação:
        pipeline = [
            {'$match': {'idade': {'$gte': 18}}},
            {'$group': {'_id': '$cidade', 'media_idade': {'$avg': '$idade'}}},
            {'$sort': {'media_idade': -1}}
        ]
        for doc in colecao.aggregate(pipeline):
            print(doc)

#Explorando Banco de Dados Relacionais com Python DB API
1. Introdução aos bancos de dados relacionais
    - Bancos relacionais organizam dados em tabelas e usam SQL para manipulação.
    - Python oferece suporte via DB API (PEP 249), padrão para conectar e manipular bancos relacionais.
    - O módulo sqlite3 é embutido no Python e ideal para testes e projetos pequenos.

2. Conectando com bancos de dados
    - Para SQLite:
        import sqlite3
        conexao = sqlite3.connect('meubanco.db')  # Cria/abre arquivo de banco
        cursor = conexao.cursor()
    - Para outros bancos (MySQL, PostgreSQL), use bibliotecas como pymysql, psycopg2, etc.

3. Criando uma tabela
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS clientes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nome TEXT NOT NULL,
            idade INTEGER,
            email TEXT
        )
    ''')
    conexao.commit()

4. Inserindo, atualizando, consultando e removendo registros
    # Inserir
    cursor.execute('INSERT INTO clientes (nome, idade, email) VALUES (?, ?, ?)', ('Ana', 30, 'ana@email.com'))
    conexao.commit()
    # Consultar
    cursor.execute('SELECT * FROM clientes')
    for row in cursor.fetchall():
        print(row)
    # Atualizar
    cursor.execute('UPDATE clientes SET idade = ? WHERE nome = ?', (31, 'Ana'))
    conexao.commit()
    # Remover
    cursor.execute('DELETE FROM clientes WHERE nome = ?', ('Ana',))
    conexao.commit()

5. Inserindo registros em lote
    dados = [
        ('João', 25, 'joao@email.com'),
        ('Maria', 28, 'maria@email.com')
    ]
    cursor.executemany('INSERT INTO clientes (nome, idade, email) VALUES (?, ?, ?)', dados)
    conexao.commit()

6. Alterando row-factory
    - O row_factory permite customizar o formato dos resultados.
    - Exemplo: retornar dicionários ao invés de tuplas.
        conexao.row_factory = sqlite3.Row
        cursor = conexao.cursor()
        cursor.execute('SELECT * FROM clientes')
        for row in cursor.fetchall():
            print(dict(row))  # {'id': 1, 'nome': 'João', ...}

7. Boas práticas
    - Sempre feche conexões e cursores (use with ou try/finally).
    - Use parâmetros (?) para evitar SQL injection.
    - Trate exceções com try/except.
    - Prefira transações para operações críticas.
    - Exemplo de uso com with:
        with sqlite3.connect('meubanco.db') as conexao:
            cursor = conexao.cursor()
            # ... operações ...

8. Gerenciando transações
    - Por padrão, sqlite3 faz autocommit após cada operação.
    - Para transações manuais:
        conexao.isolation_level = None  # Desativa autocommit
        cursor.execute('BEGIN')
        try:
            # ... operações ...
            cursor.execute('COMMIT')
        except Exception:
            cursor.execute('ROLLBACK')
    - Use transações para garantir atomicidade em operações múltiplas.


##Introdução ao Desenvolvimento Web
1. Como a Web funciona
    - A Web é baseada no modelo cliente-servidor: navegadores (clientes) enviam requisições para servidores web, que respondem com páginas ou dados.
    - O protocolo HTTP (HyperText Transfer Protocol) é o principal meio de comunicação.
    - Fluxo básico:
        * Usuário digita uma URL no navegador.
        * O navegador faz uma requisição HTTP para o servidor.
        * O servidor processa e responde com HTML, CSS, JS ou dados (JSON/XML).
        * O navegador renderiza a resposta para o usuário.

2. Tecnologias front-end e back-end
    - Front-end: parte visual/interativa da aplicação, executada no navegador.
        * Tecnologias: HTML (estrutura), CSS (estilo), JavaScript (interatividade).
        * Frameworks populares: React, Angular, Vue.js.
    - Back-end: lógica de negócio, acesso a banco de dados, autenticação, etc. Executado no servidor.
        * Tecnologias: Python (Django, Flask), Node.js, Java (Spring), PHP, Ruby, etc.
        * Responsável por processar requisições, manipular dados e responder ao cliente.

3. APIs e conceitos fundamentais
    - API (Application Programming Interface): interface que permite comunicação entre sistemas.
    - APIs Web expõem endpoints (URLs) para que clientes possam enviar/receber dados.
    - Conceitos:
        * Endpoint: URL que representa um recurso (ex: /clientes, /produtos).
        * Request: requisição feita pelo cliente (método, cabeçalhos, corpo).
        * Response: resposta do servidor (status, cabeçalhos, corpo).
        * Status HTTP: códigos que indicam o resultado (200 OK, 404 Not Found, 500 Error, etc).

4. Tipos de APIs - RESTful, SOAP e GraphQL
    - RESTful:
        * Baseada em recursos e verbos HTTP.
        * URLs representam recursos, operações são feitas via métodos HTTP.
        * Respostas geralmente em JSON.
        * Simples, escalável e amplamente usada.
    - SOAP:
        * Protocolo mais antigo, baseado em XML.
        * Estrutura rígida, usado em sistemas corporativos.
        * Opera sobre HTTP, SMTP, etc.
    - GraphQL:
        * Permite ao cliente especificar exatamente quais dados deseja.
        * Uma única URL para todas as operações.
        * Respostas em JSON, flexível e eficiente para aplicações modernas.

5. Verbos HTTP - GET, POST, PATCH, PUT e DELETE
    - GET: recupera dados de um recurso (ex: buscar lista de usuários).
    - POST: cria um novo recurso (ex: cadastrar usuário).
    - PUT: atualiza um recurso inteiro (ex: substituir dados de um usuário).
    - PATCH: atualiza parcialmente um recurso (ex: alterar só o email do usuário).
    - DELETE: remove um recurso (ex: deletar usuário).
    - Exemplo de requisições HTTP (usando requests em Python):
        import requests
        # GET
        r = requests.get('https://api.exemplo.com/usuarios')
        print(r.json())
        # POST
        r = requests.post('https://api.exemplo.com/usuarios', json={'nome': 'Ana'})
        print(r.status_code)
    - Status comuns:
                * 200 OK: sucesso
                * 201 Created: recurso criado
                * 400 Bad Request: erro na requisição
                * 401 Unauthorized: não autorizado
                * 404 Not Found: não encontrado
                * 500 Internal Server Error: erro no servidor

## Docker
1. O que é Docker?
        - Docker é uma plataforma para criar, empacotar, distribuir e executar aplicações em containers.
        - Containers são ambientes isolados que garantem que o software rode da mesma forma em qualquer lugar (desenvolvimento, teste, produção).
        - Vantagens: portabilidade, isolamento, fácil escalabilidade, reprodutibilidade de ambientes.

2. Conceitos principais
        - Imagem: blueprint (modelo) imutável de um container. Ex: imagem do Python, PostgreSQL, sua aplicação, etc.
        - Container: instância em execução de uma imagem.
        - Dockerfile: arquivo de instruções para construir uma imagem personalizada.
        - Docker Hub: repositório público de imagens prontas.

3. Comandos básicos
        - `docker pull <imagem>`: baixa uma imagem do Docker Hub.
        - `docker run <imagem>`: executa um container a partir de uma imagem.
        - `docker ps`: lista containers em execução.
        - `docker ps -a`: lista todos containers (inclusive parados).
        - `docker stop <container>`: para um container.
        - `docker rm <container>`: remove um container.
        - `docker rmi <imagem>`: remove uma imagem.
        - `docker images`: lista imagens baixadas.

4. Exemplo de Dockerfile para aplicação Python
        ```Dockerfile
        # Usa imagem oficial do Python
        FROM python:3.11
        # Define diretório de trabalho
        WORKDIR /app
        # Copia arquivos do projeto
        COPY . .
        # Instala dependências
        RUN pip install -r requirements.txt
        # Comando padrão ao iniciar o container
        CMD ["python", "main.py"]
        ```

5. Construindo e rodando sua imagem
        - Para construir: `docker build -t minha-app .`
        - Para rodar: `docker run -it --rm minha-app`

6. Docker Compose
        - Ferramenta para orquestrar múltiplos containers (ex: app + banco de dados).
        - Exemplo de docker-compose.yml:
        ```yaml
        version: '3.8'
        services:
            db:
                image: postgres:15
                environment:
                    POSTGRES_USER: user
                    POSTGRES_PASSWORD: senha
                    POSTGRES_DB: meu_banco
                ports:
                    - "5432:5432"
            app:
                build: .
                depends_on:
                    - db
                ports:
                    - "8000:8000"
        ```
        - Para subir tudo: `docker-compose up`
        - Para parar: `docker-compose down`

7. Boas práticas
        - Sempre use .dockerignore para evitar copiar arquivos desnecessários para a imagem.
        - Mantenha imagens pequenas (apenas o necessário).
        - Use variáveis de ambiente para configurações sensíveis.
        - Prefira volumes para persistir dados de bancos.

8. Recursos úteis
        - Documentação oficial: https://docs.docker.com/
        - Docker Hub: https://hub.docker.com/
        - Play with Docker (ambiente online): https://labs.play-with-docker.com/